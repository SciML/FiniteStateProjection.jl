<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>FiniteStateProjection.jl Documentation · FiniteStateProjection.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">FiniteStateProjection.jl</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href="index.html">FiniteStateProjection.jl Documentation</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#FSP-Basics"><span>FSP Basics</span></a></li><li><a class="tocitem" href="#Index-Handlers"><span>Index Handlers</span></a></li><li><a class="tocitem" href="#Function-Building"><span>Function Building</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="index.html">FiniteStateProjection.jl Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="index.html">FiniteStateProjection.jl Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/kaandocal/FiniteStateProjection.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="FiniteStateProjection.jl-Documentation"><a class="docs-heading-anchor" href="#FiniteStateProjection.jl-Documentation">FiniteStateProjection.jl Documentation</a><a id="FiniteStateProjection.jl-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#FiniteStateProjection.jl-Documentation" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>FiniteStateProjection.jl is a package that implements Finite State Projection algorithms for chemical reaction networks based on <a href="https://github.com/SciML/Catalyst.jl">Catalyst.jl</a> and <a href="https://github.com/SciML/ModelingToolkit.jl">ModelingToolkit</a>. FiniteStateProjection.jl converts descriptions of reaction networks into <code>ODEProblem</code>s that can be used to compute approximate solutions of the Chemical Master Equation with packages such as <a href="https://github.com/SciML/DifferentialEquations.jl">DifferentialEquations.jl</a>.</p><p>FiniteStateProjection.jl works by converting a <code>ReactionSystem</code> into a function that computes the right-hand side of the Chemical Master Equation:</p><p><span>$\frac{\mathrm{d}}{\mathrm{d} t} P(t) = A P(t)$</span></p><p>This function is generated dynamically via <a href="index.html#FiniteStateProjection.build_rhs"><code>build_rhs</code></a> and specialised for each <code>ReactionSystem</code>. Users can use their preferred array types supporting <code>CartesianIndices</code> and provide additional features by overloading these functions.</p><h3 id="Features:"><a class="docs-heading-anchor" href="#Features:">Features:</a><a id="Features:-1"></a><a class="docs-heading-anchor-permalink" href="#Features:" title="Permalink"></a></h3><ul><li>Flexible API for user-defined array types</li><li>Automatic dimensionality reduction for systems with conserved quantities</li><li>On-the-fly generation of specialised functions for improved performance</li></ul><h3 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h3><h4 id="Birth-Death-Model"><a class="docs-heading-anchor" href="#Birth-Death-Model">Birth-Death Model</a><a id="Birth-Death-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Birth-Death-Model" title="Permalink"></a></h4><p>This example models a linear birth-death process. The reaction network is easily defined using <a href="https://github.com/SciML/Catalyst.jl">Catalyst.jl</a>. Our truncated state space has length 50, which is enough for this simple system.</p><p>This system has no conserved quantities, so we use a <a href="index.html#FiniteStateProjection.NaiveIndexHandler"><code>NaiveIndexHandler</code></a> to map from a one-dimensional array with offset 1 to the state of the system. See <a href="index.html#Index-Handlers">Index Handlers</a> for more details.</p><pre><code class="language-julia">using FiniteStateProjection, DifferentialEquations

@parameters r1, r2
rs = @reaction_network begin
    r1, 0 --&gt; A
    r2, A --&gt; 0
end r1 r2

sys = FSPSystem(rs)

# Parameters for our system
ps = [ 10.0, 1.0 ]

# Initial values
u0 = zeros(50)
u0[1] = 1.0

prob = convert(ODEProblem, NaiveIndexHandler(sys, 1), sys, u0, 10.0, ps)
sol = solve(prob, Vern7(), atol=1e-6)</code></pre><p><img src="assets/birth_death.png" alt="Visualisation"/></p><h4 id="Telegraph-Model"><a class="docs-heading-anchor" href="#Telegraph-Model">Telegraph Model</a><a id="Telegraph-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Telegraph-Model" title="Permalink"></a></h4><p>Here we showcase the telegraph model, a simplistic description of mRNA transcription in biological cells. We have one gene that transitions stochastically between an <em>on</em> and an <em>off</em> state and produces mRNA molecules while it is in the <em>on</em> state.</p><p>This system technically consists of three different species, namely the two states of the gene and mRNA. It is clear, however, that these are not independent as <span>$D_{on}(t) + D_{off}(t) = 1$</span>. In order to solve the Chemical Master Equation we can therefore recover <span>$D_{off}(t)$</span> from the other variables and the entire state of the system is described by only two variables: <span>$D_{on}(t)$</span> and <span>$M(t)$</span>, as well as the total number of genes, which is a constant equal to <span>$1$</span>. The default index handler class <a href="index.html#FiniteStateProjection.DefaultIndexHandler"><code>DefaultIndexHandler</code></a> does this for us automatically and maps the state of the system to a two-dimensional array. This showcases that we can often reduce the number of species in the system to make it easier to solve numerically.</p><pre><code class="language-julia">using FiniteStateProjection, DifferentialEquations

@parameters r1 r2 r3 r4
rs = @reaction_network begin
    r1, G_on --&gt; G_on + M
    (r2, r3), G_on &lt;--&gt; G_off
    r4, M --&gt; 0
end r1 r2 r3 r4

sys = FSPSystem(rs)

# There is one conserved quantity: G_on + G_off
cons = conservedquantities([1,0,0], sys)

# Parameters for our system
ps = [ 15.0, 0.25, 0.15, 1.0 ]

# Since G_on + G_off = const. we do not have to model the latter separately
u0 = zeros(2, 50)
u0[1,1] = 1.0

prob = convert(ODEProblem, DefaultIndexHandler(sys, 1), sys, u0, 10.0, (ps, cons))
sol = solve(prob, Vern7(), atol=1e-6)</code></pre><p><img src="assets/telegraph.png" alt="Visualisation"/></p><h2 id="FSP-Basics"><a class="docs-heading-anchor" href="#FSP-Basics">FSP Basics</a><a id="FSP-Basics-1"></a><a class="docs-heading-anchor-permalink" href="#FSP-Basics" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="FiniteStateProjection.FSPSystem" href="#FiniteStateProjection.FSPSystem"><code>FiniteStateProjection.FSPSystem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct FSPSystem
    rs::ReactionSystem
    cons_laws::Matrix{Int}</code></pre><p>end</p><p>Thin wrapper around <code>ReactionSystem</code> for use with this package.</p><p>Constructor: <code>FSPSystem(rs::ReactionSystem)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaandocal/FiniteStateProjection.jl/blob/40c29cf42699b91edd9fbfcbce2b22651782167f/src/fspsystem.jl#L5-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteStateProjection.conservationlaws" href="#FiniteStateProjection.conservationlaws"><code>FiniteStateProjection.conservationlaws</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">conservationlaws(netstoichmat::AbstractMatrix{Int})::Matrix{Int}</code></pre><p>Given the net stoichiometry matrix of a reaction system, computes a matrix of conservation laws. Each row contains the stoichiometric coefficients of a different conserved quantity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaandocal/FiniteStateProjection.jl/blob/40c29cf42699b91edd9fbfcbce2b22651782167f/src/fspsystem.jl#L24-L31">source</a></section><section><div><pre><code class="language-none">conservationlaws(sys::FSPSystem)::Matrix{Int}</code></pre><p>Returns conservation laws associated with the system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaandocal/FiniteStateProjection.jl/blob/40c29cf42699b91edd9fbfcbce2b22651782167f/src/fspsystem.jl#L57-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteStateProjection.conservedquantities" href="#FiniteStateProjection.conservedquantities"><code>FiniteStateProjection.conservedquantities</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">conservedquantities(state, sys::FSPSystem)</code></pre><p>Compute conserved quantities for the system at the given state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaandocal/FiniteStateProjection.jl/blob/40c29cf42699b91edd9fbfcbce2b22651782167f/src/fspsystem.jl#L64-L68">source</a></section></article><h2 id="Index-Handlers"><a class="docs-heading-anchor" href="#Index-Handlers">Index Handlers</a><a id="Index-Handlers-1"></a><a class="docs-heading-anchor-permalink" href="#Index-Handlers" title="Permalink"></a></h2><p>The task of an index handler is to provide a mapping between the way the solution of the FSP is stored, usually a multidimensional array, and the states it represents. The standard approach is to store the states of a system with <span>$s$</span> reactions as an <span>$s$</span>-dimensional array and have the index <span>$(i_1, \ldots, i_s)$</span> correspond to the state <span>$(n_1 = i_1, \ldots, n_s = i_s)$</span>. This is implemented by the class <a href="index.html#FiniteStateProjection.NaiveIndexHandler"><code>NaiveIndexHandler</code></a>, which accepts an offset argument to deal with Julia&#39;s 1-based indexing (so the Julia idex <span>$(1,\ldots,1)$</span> corresponds to the state with no molecules). For systems with conservation laws the <a href="index.html#FiniteStateProjection.DefaultIndexHandler"><code>DefaultIndexHandler</code></a> class generally stores the data more efficiently and is the preferred choice.</p><p>User-defined index handlers should inherit from [<code>AbstractIndexHandler</code>] and implement the following methods:</p><ul><li><a href="index.html#FiniteStateProjection.getsubstitutions"><code>getsubstitutions</code></a></li><li><a href="index.html#FiniteStateProjection.build_rhs_header"><code>build_rhs_header</code></a></li><li><a href="index.html#FiniteStateProjection.singleindices"><code>singleindices</code></a> (optional)</li><li><a href="index.html#FiniteStateProjection.pairedindices"><code>pairedindices</code></a> (optional)</li></ul><article class="docstring"><header><a class="docstring-binding" id="FiniteStateProjection.AbstractIndexHandler" href="#FiniteStateProjection.AbstractIndexHandler"><code>FiniteStateProjection.AbstractIndexHandler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractIndexHandler end</code></pre><p><code>FSP.jl</code> splits handling of the FSP into two parts. The first defines how the CME is compute</p><p>See also: <a href="index.html#FiniteStateProjection.singleindices"><code>singleindices</code></a>, <a href="index.html#FiniteStateProjection.pairedindices"><code>pairedindices</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaandocal/FiniteStateProjection.jl/blob/40c29cf42699b91edd9fbfcbce2b22651782167f/src/indexhandlers.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteStateProjection.singleindices" href="#FiniteStateProjection.singleindices"><code>FiniteStateProjection.singleindices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">singleindices(idxhandler::AbstractIndexHandler, arr)</code></pre><p>Returns all indices <code>I</code> in <code>arr</code>. Defaults to CartesianIndices, but can be overloaded for arbitrary index handlers. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaandocal/FiniteStateProjection.jl/blob/40c29cf42699b91edd9fbfcbce2b22651782167f/src/indexhandlers.jl#L11-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteStateProjection.pairedindices" href="#FiniteStateProjection.pairedindices"><code>FiniteStateProjection.pairedindices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pairedindices(idxhandler::AbstractIndexHandler, arr, shift::CartesianIndex)</code></pre><p>Returns all pairs of indices <code>(I .- shift, I)</code> in <code>arr</code>. The default implementation can be overloaded for arbitrary index handlers. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaandocal/FiniteStateProjection.jl/blob/40c29cf42699b91edd9fbfcbce2b22651782167f/src/indexhandlers.jl#L19-L25">source</a></section><section><div><pre><code class="language-none">pairedindices(idxhandler::DefaultIndexHandler, arr::AbstractArray, shift::CartesianIndex)</code></pre><p>Similar to its <code>NaiveIndexHandler</code> variant, but converts the indices into indices into the reduced state space array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaandocal/FiniteStateProjection.jl/blob/40c29cf42699b91edd9fbfcbce2b22651782167f/src/indexhandlers.jl#L213-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteStateProjection.getsubstitutions" href="#FiniteStateProjection.getsubstitutions"><code>FiniteStateProjection.getsubstitutions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getsubstitutions(idxhandler::AbstractIndexHandler, sys::FSPSystem; state_sym::Symbol)::Dict</code></pre><p>Construct the map <code>speciesname =&gt; expr</code> that gives the species abundances in terms of the state variable <code>state_sym</code>. See <a href="index.html#FiniteStateProjection.NaiveIndexHandler"><code>NaiveIndexHandler</code></a> for the default implementation.</p><p>See also: <a href="index.html#FiniteStateProjection.build_ratefuncs"><code>build_ratefuncs</code></a>, <a href="index.html#FiniteStateProjection.build_rhs"><code>build_rhs</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaandocal/FiniteStateProjection.jl/blob/40c29cf42699b91edd9fbfcbce2b22651782167f/src/build_rhs.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteStateProjection.NaiveIndexHandler" href="#FiniteStateProjection.NaiveIndexHandler"><code>FiniteStateProjection.NaiveIndexHandler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct NaiveIndexHandler &lt;: AbstractIndexHandler
    offset::Int
end</code></pre><p>Basic index handler that stores the state of a system with <code>s</code> species in an <code>s</code>-dimensional array. The <code>offset</code> parameter denotes the offset by which the array is indexed (defaults to 1 in Julia). Use <code>OffsetArrays.jl</code> to enable 0-based indexing.</p><p>This is the simplest index handler, but it will not be optimal if some states cannot be reached from the initial state, e.g. due to the presence of conservation laws. It is generally better to use <code>DefaultIndexHandler</code>, which will automatically elide species where possible.</p><p>Constructors: <code>NaiveIndexHandler([sys::FSPSystem,] offset::Int)</code></p><p>See also: <a href="index.html#FiniteStateProjection.DefaultIndexHandler"><code>DefaultIndexHandler</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaandocal/FiniteStateProjection.jl/blob/40c29cf42699b91edd9fbfcbce2b22651782167f/src/indexhandlers.jl#L38-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteStateProjection.DefaultIndexHandler" href="#FiniteStateProjection.DefaultIndexHandler"><code>FiniteStateProjection.DefaultIndexHandler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct DefaultIndexHandler &lt;: AbstractIndexHandler</code></pre><p>More efficient index handler that improves upon <a href="index.html#FiniteStateProjection.NaiveIndexHandler"><code>NaiveIndexHandler</code></a> by eliminating variables whose abundances can be computed from other variables using conservation laws. Describes the system using a subset of the original species which can be obtained via <a href="index.html#FiniteStateProjection.reducedspecies"><code>reducedspecies</code></a>. Reduces the  dimensionality of the FSP by the number of conservation laws in the system.</p><p>Constructors: <code>DefaultIndexHandler(sys::FSPSystem, offset::Int)</code></p><p>See also: <a href="index.html#FiniteStateProjection.reducedspecies"><code>reducedspecies</code></a>, <a href="index.html#FiniteStateProjection.elidedspecies"><code>elidedspecies</code></a>, <a href="index.html#FiniteStateProjection.NaiveIndexHandler"><code>NaiveIndexHandler</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaandocal/FiniteStateProjection.jl/blob/40c29cf42699b91edd9fbfcbce2b22651782167f/src/indexhandlers.jl#L75-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteStateProjection.reducedspecies" href="#FiniteStateProjection.reducedspecies"><code>FiniteStateProjection.reducedspecies</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">reducedspecies(idxhandler::DefaultIndexHandler)</code></pre><p>Return indices of reduced species.</p><p>See also: <a href="index.html#FiniteStateProjection.elidedspecies"><code>elidedspecies</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaandocal/FiniteStateProjection.jl/blob/40c29cf42699b91edd9fbfcbce2b22651782167f/src/indexhandlers.jl#L105-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteStateProjection.elidedspecies" href="#FiniteStateProjection.elidedspecies"><code>FiniteStateProjection.elidedspecies</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">elidedspecies(idxhandler::DefaultIndexHandler)</code></pre><p>Return indices of elided species.</p><p>See also: <a href="index.html#FiniteStateProjection.reducedspecies"><code>reducedspecies</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaandocal/FiniteStateProjection.jl/blob/40c29cf42699b91edd9fbfcbce2b22651782167f/src/indexhandlers.jl#L114-L120">source</a></section><section><div><pre><code class="language-none">elidedspecies(cons_laws::AbstractMatrix{Int})::Vector</code></pre><p>Returns a list of species <span>$[ s_1, ... ]$</span> which can be removed from the reaction system description using the provided matrix of conservation laws.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaandocal/FiniteStateProjection.jl/blob/40c29cf42699b91edd9fbfcbce2b22651782167f/src/indexhandlers.jl#L125-L131">source</a></section></article><h2 id="Function-Building"><a class="docs-heading-anchor" href="#Function-Building">Function Building</a><a id="Function-Building-1"></a><a class="docs-heading-anchor-permalink" href="#Function-Building" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.convert" href="#Base.convert"><code>Base.convert</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">convert(T, x)</code></pre><p>Convert <code>x</code> to a value of type <code>T</code>.</p><p>If <code>T</code> is an <a href="@ref"><code>Integer</code></a> type, an <a href="@ref"><code>InexactError</code></a> will be raised if <code>x</code> is not representable by <code>T</code>, for example if <code>x</code> is not integer-valued, or is outside the range supported by <code>T</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; convert(Int, 3.0)
3

julia&gt; convert(Int, 3.5)
ERROR: InexactError: Int64(3.5)
Stacktrace:
[...]</code></pre><p>If <code>T</code> is a <a href="@ref"><code>AbstractFloat</code></a> or <a href="@ref"><code>Rational</code></a> type, then it will return the closest value to <code>x</code> representable by <code>T</code>.</p><pre><code class="language-julia-repl">julia&gt; x = 1/3
0.3333333333333333

julia&gt; convert(Float32, x)
0.33333334f0

julia&gt; convert(Rational{Int32}, x)
1//3

julia&gt; convert(Rational{Int64}, x)
6004799503160661//18014398509481984</code></pre><p>If <code>T</code> is a collection type and <code>x</code> a collection, the result of <code>convert(T, x)</code> may alias all or part of <code>x</code>.</p><pre><code class="language-julia-repl">julia&gt; x = Int[1, 2, 3];

julia&gt; y = convert(Vector{Int}, x);

julia&gt; y === x
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/6aaedecc447e3d8226d5027fb13d0c3cbfbfea2a/base/essentials.jl#L153-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteStateProjection.build_rhs" href="#FiniteStateProjection.build_rhs"><code>FiniteStateProjection.build_rhs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">build_rhs(idxhandler::AbstractIndexHandler, sys::FSPSystem;
          combinatoric_ratelaw::Bool)</code></pre><p>Builds the function <code>f(du,u,p,t)</code> that defines the right-hand side of the CME,  for use in the ODE solver. If <code>expression</code> is true, returns an expression, else compiles the function. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaandocal/FiniteStateProjection.jl/blob/40c29cf42699b91edd9fbfcbce2b22651782167f/src/build_rhs.jl#L122-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteStateProjection.unpackparams" href="#FiniteStateProjection.unpackparams"><code>FiniteStateProjection.unpackparams</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">unpackparams(sys::FSPSystem, psym::Symbol)</code></pre><p>Returns code unpacking the parameters of the system from the symbol <code>psym</code> in the form <code>(p1, p2, ...) = psym</code>. This should be called in all overloads of <a href="index.html#FiniteStateProjection.build_rhs_header"><code>build_rhs_header</code></a>. It is assumed that the variable <code>psym</code> is an <code>AbstractVector{Float64}</code>.</p><p>See also: <a href="index.html#FiniteStateProjection.build_rhs_header"><code>build_rhs_header</code></a>, <a href="index.html#FiniteStateProjection.build_rhs"><code>build_rhs</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaandocal/FiniteStateProjection.jl/blob/40c29cf42699b91edd9fbfcbce2b22651782167f/src/build_rhs.jl#L28-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteStateProjection.build_rhs_header" href="#FiniteStateProjection.build_rhs_header"><code>FiniteStateProjection.build_rhs_header</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">build_rhs_header(idxhandler::DefaultIndexHandler, sys::FSPSystem)::Expr</code></pre><p>Assumes <code>p</code> is of the form <code>(params, cons::AbstractVector{Int})</code> where <code>params</code>  are the system parameters and <code>cons</code> the conserved quantities.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaandocal/FiniteStateProjection.jl/blob/40c29cf42699b91edd9fbfcbce2b22651782167f/src/indexhandlers.jl#L197-L202">source</a></section><section><div><pre><code class="language-none">build_rhs_header(idxhandler::AbstractIndexHandler, sys::FSPSystem)::Expr</code></pre><p>Return initialisation code for the RHS function, unpacking the parameters <code>p</code> supplied by <code>DifferentialEquations</code>. The default implementation just unpacks parameters from <code>p</code>.</p><p>See also: <a href="index.html#FiniteStateProjection.unpackparams"><code>unpackparams</code></a>, <a href="index.html#FiniteStateProjection.build_rhs"><code>build_rhs</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaandocal/FiniteStateProjection.jl/blob/40c29cf42699b91edd9fbfcbce2b22651782167f/src/build_rhs.jl#L46-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteStateProjection.build_ratefuncs" href="#FiniteStateProjection.build_ratefuncs"><code>FiniteStateProjection.build_ratefuncs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">build_ratefuncs(idxhandler::AbstractIndexHandler, sys::FSPSystem; 
                state_sym::Symbol, combinatoric_ratelaw::Bool)::Vector</code></pre><p>Return the rate functions converted to Julia expressions in the state variable  <code>state_sym</code>. Abundances of the species are computed using <code>getsubstitutions</code>.</p><p>See also: <a href="index.html#FiniteStateProjection.getsubstitutions"><code>getsubstitutions</code></a>, <a href="index.html#FiniteStateProjection.build_rhs"><code>build_rhs</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaandocal/FiniteStateProjection.jl/blob/40c29cf42699b91edd9fbfcbce2b22651782167f/src/build_rhs.jl#L12-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteStateProjection.build_rhs_firstpass" href="#FiniteStateProjection.build_rhs_firstpass"><code>FiniteStateProjection.build_rhs_firstpass</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">build_rhs_firstpass(sys::FSPSystem, rfs)::Expr</code></pre><p>Return code for the first pass of the RHS function. Goes through all reactions and computes the negative part of the CME (probability flowing out of states). This is a simple array traversal and can be done in one go for all reactions.</p><p>See also: <a href="index.html#FiniteStateProjection.build_rhs"><code>build_rhs</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaandocal/FiniteStateProjection.jl/blob/40c29cf42699b91edd9fbfcbce2b22651782167f/src/build_rhs.jl#L64-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="FiniteStateProjection.build_rhs_secondpass" href="#FiniteStateProjection.build_rhs_secondpass"><code>FiniteStateProjection.build_rhs_secondpass</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">build_rhs_secondpass(sys::FSPSystem, rfs)::Expr</code></pre><p>Return code for the second pass of the RHS function. Goes through all reactions and computes the positive part of the CME (probability flowing into states). This requires accessing <code>du</code> and <code>u</code> at different locations depending on the net stoichiometries. In order to reduce  random memory access reactions are processed one by one.</p><p>See also: <a href="index.html#FiniteStateProjection.build_rhs"><code>build_rhs</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaandocal/FiniteStateProjection.jl/blob/40c29cf42699b91edd9fbfcbce2b22651782167f/src/build_rhs.jl#L90-L100">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 31 May 2021 15:42">Monday 31 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
